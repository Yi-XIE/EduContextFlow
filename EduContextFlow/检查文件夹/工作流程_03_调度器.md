# 🧠 调度器（Dispatcher）工作流程（补全版）

调度器不仅是“准入检查”，更是**下一步行动的决策器**。它决定：
- **做什么**（action）
- **调哪个 Skill**（skill_name）
- **下一步如何走**（ask_user / refuse / no_action / call_skill）
- **给用户哪些选项**（options）
- **是否触发同名技能链**（基于意图与上下文继续推进）

---

## 1. 输入来源与可见范围

调度器只看到：
- `user_message`（用户原文）
- `bus_state` 摘要（含 `context_index` 的**元信息**，不含正文）
- `available_skills`（技能列表及其意图描述）

它**看不到**任何上下文正文文件，也不会直接读取 outputs/。

---

## 2. 决策职责（必须明确）

调度器必须输出以下决策：

1. **action**：下一步动作
   - `call_skill` / `ask_user` / `refuse` / `no_action`

2. **skill_name**：若 `call_skill`，必须指定具体技能

3. **options**：若 `ask_user`，需给用户明确候选路径

4. **reason**：解释“为什么这样决定”

因此它不是“只判断能不能调用”，而是**决定系统下一步的完整路线**。

---

## 3. 依赖检查（准入只是其中一环）

### 3.1 LLM Prompt 层约束
Prompt 中明确要求：
- 缺少依赖 → 必须 ask_user
- 禁止凭 user_message 猜上下文

### 3.2 Python 侧硬校验
```python
if action == "call_skill":
    is_valid, reason = _validate_skill_requirements(...)
    if not is_valid:
        return ask_user(...)
```

**说明**：这是“强制拦截”，不允许越权。

---

## 4. 输出格式（严格约束）

调度器输出 JSON：
```json
{
  "action": "call_skill | ask_user | refuse",
  "skill_name": "string | null",
  "reason": "string",
  "question": "string (仅 ask_user)",
  "options": ["string"] (仅 ask_user)
}
```

**禁止**输出 `input` 或 `input_hints`，避免认知污染。

---

## 5. 与 App 的协作边界

- 调度器决定“要做什么”
- App 决定“执行器看到什么上下文”
- Executor 只执行，不读取上下文

---

## ✅ 总结一句话

**调度器不是“只做准入检查”**，它是整个系统“下一步行动决策”的唯一来源。

